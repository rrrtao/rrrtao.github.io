{"meta":{"title":"比特笔","subtitle":"个人笔记","description":"比特笔 - Java，Nodejs，GO，上古码农，统治六界，降妖除魔，国泰民安，建房种树，喝茶聊码。","author":"比特笔","url":"http://btbib.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-04-06T03:11:04.000Z","updated":"2020-04-06T03:11:04.000Z","comments":false,"path":"/404.html","permalink":"http://btbib.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-03-17T04:53:56.000Z","updated":"2020-03-17T04:53:56.000Z","comments":false,"path":"books/index.html","permalink":"http://btbib.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-05T03:21:29.000Z","updated":"2020-04-05T03:21:29.000Z","comments":false,"path":"about/index.html","permalink":"http://btbib.com/about/index.html","excerpt":"","text":"上古码农，统治六界，降妖除魔，国泰民安，建房种树，喝茶聊码。"},{"title":"友情链接","date":"2020-03-17T04:53:56.000Z","updated":"2020-03-17T04:53:56.000Z","comments":true,"path":"links/index.html","permalink":"http://btbib.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-17T10:29:03.000Z","updated":"2020-03-17T10:29:03.000Z","comments":false,"path":"categories/index.html","permalink":"http://btbib.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-17T04:53:56.000Z","updated":"2020-03-17T04:53:56.000Z","comments":false,"path":"tags/index.html","permalink":"http://btbib.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-17T04:53:56.000Z","updated":"2020-03-17T04:53:56.000Z","comments":false,"path":"repository/index.html","permalink":"http://btbib.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"VMware搭建简易版本k8s集群v1.18.3","slug":"VMware搭建最新k8s集群v1-18-3","date":"2020-06-17T04:37:39.000Z","updated":"2020-06-17T04:56:00.016Z","comments":true,"path":"2020-06-17-1.html","link":"","permalink":"http://btbib.com/2020-06-17-1.html","excerpt":"","text":"环境 环境 说明 宿主机 win10（16G） VMware 15.5.1 centOS 7 下载地址 虚拟机 环境 说明 10.0.0.128 master-k8s 4C4G 10.0.0.129 node2-k8s 4C4G 10.0.0.130 node3-k8s 4C4G 先在 master-k8s 上安装基本软件服务，然后在克隆node2-k8s,node3-k8s * 3台centos都要执行的步骤 [start] * 关闭防火墙顺序执行命令： iptables -F setenforce 0 systemctl stop firewalld systemctl disable firewalld 修改hostname执行命令： vi /etc/hostname10.0.0.128 改成 master-k8s10.0.0.129 改成 node2-k8s10.0.0.130 改成 node3-k8s 修改host文件vi /etc/hosts 12345127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain610.0.0.128 master-k8s10.0.0.129 node2-k8s10.0.0.130 node3-k8s 禁用swap执行命令： swapoff -a vi /etc/fstab 找到下面行在前面加一个 # 注释 swap功能 #/dev/mapper/centos-swap swap swap defaults 0 0 #禁用swap自动挂载 安装Docker顺序执行命令： 12345sudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.iosystemctl start docker.servicesystemctl enable docker.service 配置阿里云镜像加速器 12345cat&gt;&gt;/etc/docker/daemon.json&lt;&lt;EOF&#123; \"registry-mirrors\":[ \"https://x6stvqqp.mirror.aliyuncs.com\" ]&#125;EOF 上面执行完后 重启docker生效 执行命令： systemctl daemon-reload systemctl restart docker 添加K8s国内镜像源 1234567cat&gt;&gt;&#x2F;etc&#x2F;yum.repos.d&#x2F;kubrenetes.repo&lt;&lt;EOF[kubernetes]name&#x3D;Kubernetes Repobaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64&#x2F;gpgcheck&#x3D;0gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpgEOF 安装K8s所需要的3个组件执行命令： 1yum install -y kubeadm-1.18.3 kubelet-1.18.3 kubectl-1.18.3 说明： kubeadm：安装工具，使所有的组件都会以容器的方式运行 kubectl：客户端连接K8S API工具 kubelet：运行在node节点，用来启动容器的工具 设置k8s开机自启动执行命令： 1systemctl enable kubelet.service 加载内核模块 1234567cat&gt;&gt;&#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables &#x3D; 1net.bridge.bridge-nf-call-iptables &#x3D; 1net.ipv4.ip_nonlocal_bind &#x3D; 1net.ipv4.ip_forward &#x3D; 1vm.swappiness&#x3D;0EOF 然后执行 vi /etc/sysctl.conf 填写： net.ipv4.ip_forward = 1 执行命令： sysctl -p 执行命令： 123456789cat &gt; &#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules &lt;&lt;EOF#!&#x2F;bin&#x2F;bashmodprobe -- br_netfiltermodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF 执行命令： chmod 755 /etc/sysconfig/modules/ipvs.modules bash /etc/sysconfig/modules/ipvs.modules lsmod | grep -E “ip_vs|nf_conntrack_ipv4” * 上面的步骤需要在3台centos虚拟机都得执行的！[end] * 建议：现在master-k8s上完成配置，然后克隆，修改hostname 下面的步骤只在master-k8s 机器上操作通过如下指令创建默认的kubeadm-config.yaml文件： 执行命令： kubeadm config print init-defaults &gt; kubeadm-config.yaml 然后修改 kubeadm-config.yaml配置 下面有注释的地方就是要修改的地方！ 12345678910111213141516171819202122232425262728293031323334353637383940[root@master-k8s ~]# vi kubeadm-config.yamlapiVersion: kubeadm.k8s.io&#x2F;v1beta2bootstrapTokens:- groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authenticationkind: InitConfigurationlocalAPIEndpoint: advertiseAddress: 10.0.0.128 #master节点的IP bindPort: 6443nodeRegistration: criSocket: &#x2F;var&#x2F;run&#x2F;dockershim.sock name: 10.0.0.128 #修改为IP地址，如果使用域名，必须保证解析正常 taints: - effect: NoSchedule key: node-role.kubernetes.io&#x2F;master---apiServer: timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io&#x2F;v1beta2certificatesDir: &#x2F;etc&#x2F;kubernetes&#x2F;pkiclusterName: kubernetescontrollerManager: &#123;&#125;dns: type: CoreDNSetcd: local: dataDir: &#x2F;var&#x2F;lib&#x2F;etcd #把etcd容器的目录挂载到本地的&#x2F;var&#x2F;lib&#x2F;etcd目录下，防止数据丢失imageRepository: registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers #镜像仓库地址kind: ClusterConfigurationkubernetesVersion: v1.18.3 #Kubernetes软件版本networking: dnsDomain: cluster.local serviceSubnet: 10.96.0.0&#x2F;12 podSubnet: 10.244.0.0&#x2F;16 #添加这个内容scheduler: &#123;&#125; 预先下载镜像执行命令： kubeadm config images pull –config kubeadm-config.yaml 执行命令： echo ‘1’ &gt; /proc/sys/net/bridge/bridge-nf-call-iptables 安装matser节点执行命令： kubeadm init –config kubeadm-config.yaml 如果输出以下信息表示，swap没有被禁用 [ERROR Swap]: running with swap on is not supported. Please disable swap 输出以下信息表示，请执行echo ‘1’ &gt; /proc/sys/net/bridge/bridge-nf-call-iptables [ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1 安装成功后注意看console上运行的信息 执行命令： 123mkdir -p $HOME&#x2F;.kubesudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;configsudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config 在master-k8s获取token、cert-hash1234567891011[root@master-k8s]# kubeadm token createkiyfhw.xiacqbch8o8fa8qj[root@master-k8s]# kubeadm token listTOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPSabcdef.0123456789abcdef &lt;invalid&gt; 2020-06-10T14:16:06+08:00 authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-tokenkiyfhw.xiacqbch8o8fa8qj 23h 2020-06-10T06:39:24+08:00 authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-token# 生成ca的sha256 hash值[root@master-k8s]# openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | openssl dgst -sha256 -hex | sed &#39;s&#x2F;^.* &#x2F;&#x2F;&#39;5417eb1b68bd4e7a4c82aded83abc55ec91bd601e45734d6aba85de8b1ebb057 kubeadm join把下面的命令拿到 10.0.0.129/10.0.0.130 工作节点虚拟机上运行 1kubeadm join 10.0.0.128:6443 --token kiyfhw.xiacqbch8o8fa8qj --discovery-token-ca-cert-hash sha256:5417eb1b68bd4e7a4c82aded83abc55ec91bd601e45734d6aba85de8b1ebb057 若果有失败提示在node节点上配置信息 vi /etc/docker/daemon.json 1234&#123; \"registry-mirrors\":[ \"https://x6stvqqp.mirror.aliyuncs.com\" ], \"exec-opts\":[\"native.cgroupdriver=systemmd\"]&#125; 以上运行成功 检测下 在master-k8s执行命令 sudo kubectl get nodes 你会发现 Status 是 NotReady，因为没有安装网络插件！ 安装网络插件flannel因为上面我们安装的的k8s的版本是 v 1.18.3 这个版本对应的 flannel 版本是：v0.12.0 因为由于某种不可抗力 一定得先下载好docker镜像！ docker pull quay-mirror.qiniu.com/coreos/flannel:v0.12.0-amd64 下载 flannel 的 yml文件： wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 执行命令： kubectl apply -f kube-flannel.yml 等待k8s 把 pod：flannel生效 可以用命令查看状态进度： kubectl get pods -n kube-system 等 flannel 状态显示 Running后 执行查看k8s集群运行状态命令： kubectl get nodes NAME STATUS ROLES AGE VERSION 10.0.0.128 Ready master 30m v1.18.3 node2-k8s NotReady 50m v1.18.3 node3-k8s NotReady 51m v1.18.3 发现master已经Ready了 但是工作node没有起来，状态是NotReady 下面去配置工作node虚拟机上的flannel配置 10.0.0.129 是我的工作node2-k8s 运行命令把master节点的配置copy到工作节点 scp -r 10.0.0.128:/etc/cni /etc/cni 重启启动 kubelet systemctl restart kubelet 回到master节点查看 执行查看k8s集群运行状态命令： kubectl get nodes NAME STATUS ROLES AGE VERSION 10.0.0.128 Ready master 30m v1.18.3 node2-k8s Ready 55m v1.18.3 node3-k8s Ready 56m v1.18.3 kubectl get pods -n kube-system 发现 有两个flannel 容器没有起来，那么在node2-k8s，node3-k8s检查是否有如下信息,没有就添加。 12345cat &#x2F;run&#x2F;flannel&#x2F;subnet.envFLANNEL_NETWORK&#x3D;10.244.0.0&#x2F;16FLANNEL_SUBNET&#x3D;10.244.1.1&#x2F;24FLANNEL_MTU&#x3D;1450FLANNEL_IPMASQ&#x3D;true 安装Dashboard UI v2.0.1参考地址： 部署文件 Github 地址：https://github.com/my-dlq/blog-example/tree/master/kubernetes/kubernetes-dashboard2.0.0-deploy 1、Dashboard RBAC创建 Dashboard RBAC 部署文件 k8s-dashboard-rbac.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273apiVersion: v1kind: ServiceAccountmetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-systemrules: - apiGroups: [\"\"] resources: [\"secrets\"] resourceNames: [\"kubernetes-dashboard-key-holder\", \"kubernetes-dashboard-certs\", \"kubernetes-dashboard-csrf\"] verbs: [\"get\", \"update\", \"delete\"] - apiGroups: [\"\"] resources: [\"configmaps\"] resourceNames: [\"kubernetes-dashboard-settings\"] verbs: [\"get\", \"update\"] - apiGroups: [\"\"] resources: [\"services\"] resourceNames: [\"heapster\", \"dashboard-metrics-scraper\"] verbs: [\"proxy\"] - apiGroups: [\"\"] resources: [\"services/proxy\"] resourceNames: [\"heapster\", \"http:heapster:\", \"https:heapster:\", \"dashboard-metrics-scraper\", \"http:dashboard-metrics-scraper\"] verbs: [\"get\"]---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboardrules: - apiGroups: [\"metrics.k8s.io\"] resources: [\"pods\", \"nodes\"] verbs: [\"get\", \"list\", \"watch\"]---apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-systemroleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: kubernetes-dashboardsubjects: - kind: ServiceAccount name: kubernetes-dashboard namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: kubernetes-dashboard namespace: kube-systemroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kubernetes-dashboardsubjects: - kind: ServiceAccount name: kubernetes-dashboard namespace: kube-system 部署 Dashboard RBAC kubectl apply -f k8s-dashboard-rbac.yaml 2 创建 ConfigMap、Secret创建 Dashboard Config &amp; Secret 部署文件 k8s-dashboard-configmap-secret.yaml 123456789101112131415161718192021222324252627282930313233343536apiVersion: v1kind: Secretmetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard-certs namespace: kube-systemtype: Opaque---apiVersion: v1kind: Secretmetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard-csrf namespace: kube-systemtype: Opaquedata: csrf: \"\"---apiVersion: v1kind: Secretmetadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard-key-holder namespace: kube-systemtype: Opaque---kind: ConfigMapapiVersion: v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard-settings namespace: kube-system 部署 Dashboard Config &amp; Secret kubectl apply -f k8s-dashboard-configmap-secret.yaml 3 kubernetes-dashboard创建 Dashboard Deploy 部署文件k8s-dashboard-deploy.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485kind: ServiceapiVersion: v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-systemspec: type: NodePort ports: - port: 443 nodePort: 30001 targetPort: 8443 selector: k8s-app: kubernetes-dashboard---## Dashboard Deploymentkind: DeploymentapiVersion: apps&#x2F;v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-systemspec: replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: k8s-app: kubernetes-dashboard template: metadata: labels: k8s-app: kubernetes-dashboard spec: serviceAccountName: kubernetes-dashboard containers: - name: kubernetes-dashboard image: kubernetesui&#x2F;dashboard:v2.0.1 securityContext: allowPrivilegeEscalation: false readOnlyRootFilesystem: true runAsUser: 1001 runAsGroup: 2001 ports: - containerPort: 8443 protocol: TCP args: - --auto-generate-certificates - --namespace&#x3D;kube-system #设置为当前部署的Namespace resources: limits: cpu: 1000m memory: 512Mi requests: cpu: 1000m memory: 512Mi livenessProbe: httpGet: scheme: HTTPS path: &#x2F; port: 8443 initialDelaySeconds: 30 timeoutSeconds: 30 volumeMounts: - name: kubernetes-dashboard-certs mountPath: &#x2F;certs - name: tmp-volume mountPath: &#x2F;tmp - name: localtime readOnly: true mountPath: &#x2F;etc&#x2F;localtime volumes: - name: kubernetes-dashboard-certs secret: secretName: kubernetes-dashboard-certs - name: tmp-volume emptyDir: &#123;&#125; - name: localtime hostPath: type: File path: &#x2F;etc&#x2F;localtime tolerations: - key: node-role.kubernetes.io&#x2F;master effect: NoSchedule 部署 Dashboard Deploy kubectl apply -f k8s-dashboard-deploy.yaml 4 创建 kubernetes-metrics-scraper创建 Dashboard Metrics 部署文件 k8s-dashboard-metrics.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879kind: ServiceapiVersion: v1metadata: labels: k8s-app: dashboard-metrics-scraper name: dashboard-metrics-scraper namespace: kube-systemspec: ports: - port: 8000 targetPort: 8000 selector: k8s-app: dashboard-metrics-scraper---## Dashboard Metrics Deploymentkind: DeploymentapiVersion: apps&#x2F;v1metadata: labels: k8s-app: dashboard-metrics-scraper name: dashboard-metrics-scraper namespace: kube-systemspec: replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: k8s-app: dashboard-metrics-scraper template: metadata: labels: k8s-app: dashboard-metrics-scraper annotations: seccomp.security.alpha.kubernetes.io&#x2F;pod: &#39;runtime&#x2F;default&#39; spec: serviceAccountName: kubernetes-dashboard containers: - name: dashboard-metrics-scraper image: kubernetesui&#x2F;metrics-scraper:v1.0.4 securityContext: allowPrivilegeEscalation: false readOnlyRootFilesystem: true runAsUser: 1001 runAsGroup: 2001 ports: - containerPort: 8000 protocol: TCP resources: limits: cpu: 1000m memory: 512Mi requests: cpu: 1000m memory: 512Mi livenessProbe: httpGet: scheme: HTTP path: &#x2F; port: 8000 initialDelaySeconds: 30 timeoutSeconds: 30 volumeMounts: - mountPath: &#x2F;tmp name: tmp-volume - name: localtime readOnly: true mountPath: &#x2F;etc&#x2F;localtime volumes: - name: tmp-volume emptyDir: &#123;&#125; - name: localtime hostPath: type: File path: &#x2F;etc&#x2F;localtime nodeSelector: &quot;beta.kubernetes.io&#x2F;os&quot;: linux tolerations: - key: node-role.kubernetes.io&#x2F;master effect: NoSchedule 部署 Dashboard Metrics kubectl apply -f k8s-dashboard-metrics.yaml 5 创建访问的 ServiceAccount创建一个绑定 admin 权限的 ServiceAccount，获取其 Token 用于访问看板。 创建 Dashboard ServiceAccount 部署文件 k8s-dashboard-token.yaml 1234567891011121314151617181920212223kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io&#x2F;v1metadata: name: admin annotations: rbac.authorization.kubernetes.io&#x2F;autoupdate: &quot;true&quot;roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.iosubjects:- kind: ServiceAccount name: admin namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata: name: admin namespace: kube-system labels: kubernetes.io&#x2F;cluster-service: &quot;true&quot; addonmanager.kubernetes.io&#x2F;mode: Reconcile 部署访问的 ServiceAccount kubectl apply -f k8s-dashboard-token.yaml 获取 Token kubectl describe secret/$(kubectl get secret -n kube-system |grep admin|awk ‘{print $1}’) -n kube-system token： xxxxxxxx.xxxxxxx.xxxxxx 登录https://10.0.0.128:30001","categories":[{"name":"容器云","slug":"容器云","permalink":"http://btbib.com/categories/%E5%AE%B9%E5%99%A8%E4%BA%91/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://btbib.com/tags/k8s/"}]},{"title":"技术Leader的30条军规","slug":"技术Leader的30条军规","date":"2020-05-11T06:16:25.000Z","updated":"2020-05-11T07:33:25.000Z","comments":true,"path":"2020-05-11-1.html","link":"","permalink":"http://btbib.com/2020-05-11-1.html","excerpt":"","text":"骑白马的不一定是王子，可能是唐僧；有翅膀的不一定是天使，也可能是鸟人。 1、 组建12人左右的最小战斗单元。有时候人多并没有用，比如一个孕妇怀胎10月生下一个宝宝，你不可能找来10个孕妇怀胎一个月，就能生下来吧。 2、每两周一个迭代，并持续对产品方向做对焦，打造杀手级应用。在VUCA时代（是指变化莫测的时代），只有打造极致的产品和服务，才有机会胜出。就像奔驰的广告语：The best or nothing。 3、高效会议，会前发出议题，与会人提前做准备，会议要有结论，执行结果有跟踪。尽量心平气和地讨论，你每次忍不住骂别人的时候，要考虑对方的感受，尽量不要用方言，因为对方会听不懂。 4、使用时间管理工具，每天做时间计划，发送给你的直属领导和团队。时间最牛逼了，它不用通知任何人，就能改变一切。要掌握的工具有：番茄工作法、GTD工具或App。 5、每周做团队效率分析，包括资源使用率、评估团队产出、KPI完成情况。鼓励团队挑战高目标，比如一次下雨天，有辆兰博基尼经过，溅了我一身水，当时我就发誓，等我有钱了，一定买一身雨衣。 6、组织团队内部分享、交流心得，将最佳实践更新到WIKI上。比如最近股市行情那么差，炒股亏了多少，说出来大家高兴高兴。需要使用到的工具和方法有：GROW模型、TTT培训。 7、采用Scrum或Kanban等敏捷开发模式，持续提升团队成熟度。Leader能够担任敏捷教练，指导团队快速迭代，自我完善。集体反思复盘是非常重要的，当一个人说我丑的时我不以为然，当越来越多人说我丑的时候，我才知道现在骗子越来越多了。 8、每周周会，提出Team的HighLight、LowLight和需要改进的地方、下周完成的改进点。有的同事加个班还发朋友圈，恨不得让全世界都知道，这是不成熟的表现，我就不一样，我只想让领导知道。 9、学习邮件礼仪，善用邮件组过滤功能，提高邮件处理效率。需要掌握的工具方法有：基于金字塔原理、MECE的文字表达方式。凡事发邮件的习惯非常好，因为撕逼的时候可以拿出来当证据。 10、Sprint中的TASK粒度在0.5~1天之内。颗粒度的大小，都要有个度。比如找女朋友就要找个胖的，花同样的钱你挑了个最大的，不好吗？ 11、每天跟团队开站会，及时发现和解决项目中的问题。如果Leader还要Coding，先确保团队的工作正常进行，再去写自己的代码，切忌重心颠倒。 12、Product backlog里随时有足够团队开发一个月的需求设计，确保一个迭代完成可马上进入下一迭代，团队“零等待”。普通Leader从头盯到尾，高手狠抓衔接环节，比如从需求评审到开发，从开发转测试，中间衔接不上是最常见的浪费。精益“拉动式”生产的灵魂就是，减少在制品的等待时长。 13、异地团队协作，必须有接口人，由接口人负责日常需求沟通，保持1对1沟通，禁止多对多的网状沟通。疫情逼得我们提前适应了云办公，但是视频会议的时候，要注意礼仪，至少洗个头、画下眉毛眼睛、下身要穿点什么，别着凉。 14、Scrum中的工时预估必须double check，有争议需提交技术Leader进行裁决。需要掌握的方法：故事点、扑克估算。讨论问题的时候要提高效率，有些同学讨论半天，最后还动手了，结果还是没解决，我不一样，我上来直接打。 15、遵守Code review规范，使用sonar，findbugs等工具做静态扫描，减少低级错误。Code review既达成代码审查目的，又可以分享团队成员的经验。一举两得的事，要坚持。 16、项目管理，使用Jira、readmine等工具提效。数据可视化、透明化带来效率提升。虽说，开兰博基尼和拖拉机，都可以到达终点，但是兰博基尼能泡到嫩模，拖拉机只能泡到村姑，这大概就是差别吧。 17、每周测试leader做bug分析、开发leader代码质量问题分析、维护到WIKI。质量的第一责任人是开发自己，而不是测试。注意提bug的礼仪，可以这样说，我Cao，这个算法太牛X了，哪个大神写的？当一群开发围过来的时候，指着头发最多的那个，这bug就是你的，滚回去改！ 18、每周例会让成员展示工作成果，如：设计、算法等，增加员工成就感。周会增强仪式感，让员工从工作中获得成就感，得到快乐。我每天上班都很注重仪式感，开始工作之前，做好计划、思考一天最重要的事情、冥想解决的最佳办法，然后，然后就下班了。 19、每天跟组员有沟通，一起吃饭，关心生活，异地同事多进行语音交流替代打字。同事之间相处，就不要耍心机了，反正几十年后都要一起去跳广场舞的。 20、对表现突出的员工，公开邮件表扬，申请即时奖励，事迹更新到wiki。当然了，用钱并不能买到快乐，只是有钱，别人会想尽办法让你快乐。所以，要努力工作，多挣钱。 21、跟组员每月一次one on one，帮助解决工作和生活中遇到的问题。比如员工找不到对象，要劝他不要怨天尤人，要多想想自己的原因，也许是因为他太优秀了，没人配得上他呢。 22、每月一次团队活动，如：桌游、体育活动。多鼓励单身码农们，认认真真去谈一次恋爱，不然他们根本不知道一个人过得有多爽。 23、员工生日时，给员工送上有纪念意义的小礼物，增强归属感。你很可能是他生命中除了父母、银行、各种App之外，唯一记住他生日的人。 24、每月更新团队“文化墙”，展示团队风貌。给团队定制Logo、标语、队服等等，像一大家子那样。比如一句走心的Slogan：就算做咸鱼，也要做最咸的那一条。 25、每季度举行部门会议，总结部门季度工作，嘉奖表现突出、进步快的员工。物质激励之外，精神激励同样重要，物质激励像父爱那样厚重，精神激励像母爱那样绵长。 26、每季度举行部门outing，增加团队凝聚力。出去旅游的话，多做些攻略，最好的攻略可以浓缩成四个字：多带点钱。 27、团队内建立backup机制，实行A/B角，包括Leader自己。避免因为团队成员升迁或离职造成项目进度的延期。备胎转正，是一条成功的捷径。 28、使用情境领导方法，管理和培养不同等级的员工。掌握：情景领导方法、九宫格人才盘点等方法。还是任正非说得有道理，什么是人才？钱给够了，不是人才也会变成人才。我终于明白自己这么多年，不能成为人才的真正原因了。 29、帮助员工做职业规划，每月制定提升计划，监督完成情况。让员工明白一个道理，年轻的时候不要怕吃苦，因为只有这样，当你老了吃苦的时候才会习惯。 30、鼓励下属反馈问题，主动向下沟通，鼓励大家发表观点。在团队中鼓励积极向上的人生态度。假如生活欺骗了你，不要着急，拿出美颜相机，去欺骗生活。 作者| Mr.K 编辑| Emma来源| 技术领导力(ID：jishulingdaoli)","categories":[{"name":"管理","slug":"管理","permalink":"http://btbib.com/categories/%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"Leader","slug":"Leader","permalink":"http://btbib.com/tags/Leader/"}]},{"title":"MySQL数据库开发规范","slug":"MySQL数据库开发规范","date":"2020-03-27T00:50:26.000Z","updated":"2020-03-28T07:55:13.000Z","comments":true,"path":"2020-03-27-3.html","link":"","permalink":"http://btbib.com/2020-03-27-3.html","excerpt":"","text":"一. 数据库核心规范 尽量不要在数据库做运算：cpu计算请移至业务层. 控制单表数据量：单表记录控制在1000w行.（也可以考虑分区） 控制列数量：单表字段数上限控制在20到50之内.字段少而精可以提高并发，IO更高效 (优化InnoDB表BLOB列的存储效率) 平衡范式与冗余：效率优先，提高性能. 适时牺牲范式增加冗余 拒绝3B：拒绝大sql(BIG SQL)，大事务(BIG TRANSATION)，大批量(BIG BATCH). 二. 命名规范在MySQL数据库中，表名、字段名、触发器、存储过程以及函数的命名，统一采用26个英文字母（区分大小写）和0－9这十个自然数，加上下划线_组成，共63个字符.不能出现其他字符（注释除外）,也不能以数字或‘_’ 开头，非必须情况下，不使用自然数. 对于MySQL数据库， 表名、字段名统一采用小写字母; (Oracle数据库中表名、字段名统一采用大写字母)若名称过长可采用单词缩写. 1. 表名:根据表所描述的业务实体，采用英文单词加_的形式命名.若表名太长，英文单词可采用缩写.如：prodcut_info. 2. 视图命名：视图名加_view”后缀。 如：prodcut_info_view. MySQL因为没有物化视图，因此视图能不用就尽量少用。对于sql监控来讲，视图的sql存储在数据库中，分析时很不直观。 3. 触发器命名：触发器功能描述名加“_tr”后缀。 如:insert_balance_hist_tr. 4. 存储过程：存储过程功能描述名加“_sp”后缀。如：load_user_trade_sp. 5. 函数名：函数功能描述加“_fn”后缀。 如：generate_password_fn. 6. 键名： 主键：主键字段或主键描述加“_pk” 如：product_id_pk 外键：外键字段 加“_fk” 如：product_id_fk 索引：索引字段或索引描述 加 _idx 如：name_idx. 三.设计规范1. 注释表结构中须包含表注释和列注释. 对于函数、触发器以及存储过程等，代码开头应有阐述其功能的注释.若有复杂逻辑，则应加上局部注释. 2. 数据引擎选择全部选择InnoDB。MyISAM一旦出现系统宕机或者进程崩溃情况容易造成存储数据损坏。 此外，频繁读写的InnoDB表，一定要使用具有自增/顺序特征的整型作为显式主键。 为什么InnoDB表要建议用自增列做主键 3. 编码所有数据表均采用UTF8编码，并在表DDL中明确标出.所有字段都不单独设编码，即采用默认的表编码UTF8. 比如可以设置表的编码 CREATE DATABASE IF NOT EXISTS test_db default charset utf8 COLLATE utf8_general_ci;注意后面这句话COLLATE utf8_general_ci,意思是在排序时根据utf8校验集来排序，那么在这个数据库下创建的所有数据表的默认字符集都会是utf8了 4. 字段选择4.1 IP字段如果是使用的IPV4，则使用int存储不使用char(15). 在MySQL中提供了INER_ATONO()和INET_NTOA()函数来对IP和数字之间进行转换. 前者提供IP到数字的转换后者提供数字到IP的转换. insert into table column(ipvalues(INET_ATONO(&apos;127.0.0.1&apos;)) ;如业务需求需要存储IPV6，可采用varchar(40)类型. 4.2 手机字段如果考虑到varchar占用空间大影响查询性能，请使用bigint来存储手机号码. 不要使用int，因为int类型的最大长度不能超过11位 如果手机号码中含有地区码，则用varchar 4.3 enum，set和tinyint类型使用枚举类型可以使用ENUM，ENUM的内部存储机制是采用TINYINT或SMALLINT（并非CHAR/VARCHAR）。 注意：ENUM类型扩展性较差，如果新增枚举值，需要修改表字段定义，而且在执行ddl时会对性能有影响 4.4 金额字段对于金额字段，统一采用decimal(17,0)类型，金额以“分”为单位保存. 4.5 时间字段时间字段优先考虑datetime. 4.6 精确浮点数字段必须使用decimal替代float和doubleMySQL中的数值类型(不包括整型)IEEE754浮点数：单精度(float)、双精度(double和real)、 定点数(decimal和numeric). float，double等非标准类型，在DB中保存的是近似值，而decimal则以字符串的形式保存数值 4.7 辅助字段为便于数据分析，所有表必须添加两个字段： raw_add_time timestamp DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;, raw_update_time timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;修改时间&apos;这两个字段只记录每条记录的创建时间及更新时间. 5 禁止在数据库里存图片和文件禁止在数据库中使用varbinary、blob、text存储图片和文件. 6 数据库完整性要求不在数据库层面约束数据的完整性，数据的完整性由程序来保证. 所以也禁止使用外键。 四. 索引规范MySQL的查询速度依赖良好的索引设计，因此索引对于高性能至关重要. 合理的索引(哪怕是基于索引的条件过滤，如果优化器意识到总共需要扫描的数据量超过30%时，就会直接改变执行计划为全表扫描，不再使用索引。)会加快查询速度(包括UPDATE和DELETE的速度，MySQL会将包含该行的page加载到内存中，然后进行UPDATE或者DELETE操作),不合理的索引会降低速度.如果没有索引，MySQL会进行全表扫描，消耗大量IO. 1 谨慎合理的添加索引索引能改善查询的效率，但是也会增加额外的开销并减慢更新的速度(更新时会同时更新索引). 索引的数量不是越多越好，能不加的索引尽量不加. InnoDB的secondary index(非主键索引）使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度. 按照目前的业务需求，单表的索引应符合下列要求： 索引数量控制在5个左右，单个索引的字段不超过5个.在设计的时候要结合SQL和需求考虑索引的覆盖. 唯一键由3个以下字段组成，当字段都是整形时，使用唯一键作为主键. 唯一键不和主键重复，即不得在主键上建唯一索引. 较长的字段需加入前缀索引来减少索引长度，提高效率. 例子如下: create table url( address VARCHAR(100) NOT NULL，index idx_url(address(10))); 前缀索引长度依据索引的覆盖率来定,建立索引之前最好查看下对应字段建立索引的概率.MySQL5.6优化了合并索引，也就是说一条SQL上可以使用两个索引了. 2 提高索引的覆盖率合理利用覆盖索引. 关于覆盖索引：InnoDB 存储引擎中，secondary index（非主键索引）中没有直接存储行地址，而存储主键值. 如果用户需要查询secondary index中所不包含的数据列时，需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次. 覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是覆盖索引. 合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升.比如SELECT email,uid FROM user_email WHERE uid=xxx，可以将索引添加为index(uid,email)，以提升性能. 索引字段的顺序需要考虑字段值去重之后的个数，个数多的放在前面.合理创建联合索引（避免冗余），(a,b,c相当于 (a、(a,b、(a,b,c). 遵循最左原则.UPDATE、DELETE语句需要根据WHERE条件添加索引. 3 索引使用需要注意的事项 不建议使用%前缀模糊查询，例如LIKE &quot;%xxx&quot;，这样会扫全表. 不要在索引列进行数学或者函数计算. select * from table where id +1 =10000; 这样不会使用索引，导致扫全表，改为: select * from table where id =10000-1; 使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，Using Temporary. 下面列出extra列常见的值: a. Using Temporary 为了解决查询，MySQL需要创建一个临时表来容纳结果. 典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句. 使用临时表的开销是比较大的. b. Using File Sort MySQL需要额外的一次传递，以找出如何按排序顺序检索行. 出现这个说明SQL没有走索引. MySQL通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序. c. Using index 从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息. d. Using where MySQL使用where条件进行过滤找到匹配行返回客户端. 禁止使用外键. 因为会产生额外开销，并且是逐行进行操作. 最关键的是在高并发的情况下很容易造成死锁. SQL变更需要确认索引是否需要变更，并通知DBA. 五. SQL规范1. 核心思想 使用prepared statement，可以提高性能并且避免SQL注入. 尽量避免大SQL，因为在高并发的情况下，一个大SQL容易堵死数据库. 2. 注意事项线上MySQL采用的是5.6版本，所以下列都以5.6版本为例子. 2.1 使用合理的分页方式以提高分页的效率.例子如下： SELECT * FROM TABLE ORDER BY IDLIMIT 1000000,10;这种分页方式会导致大量的io，因为MySQL使用的是提前读取策略, LIMIT越大效率越低. 另外UPDATE、DELETE语句不使用LIMIT. 上面sql应改为: SELECT * FROM TABLE WHERE ID &gt; LAST_ID ORDER BY ID LIMIT 10 (LAST_ID为具体值)2.2 SELECT语句只获取需要的字段用select * 时会消耗更多的CPU，内存，IO，当表越大时消耗越大. 只读取有效的字段，可以提高索引覆盖，而且更安全(可以减少表变化带来的影响),减少网络传输、磁盘io时间。 2.3 避免负向查询和前缀模糊查询前缀模糊查询是不能使用索引. 负向查询是!=,&lt;&gt;, not in ,not exits,not like.是会导致无法使用索引的. 2.4 WHERE条件中必须使用合适的类型WHERE条件中的字符类型与对应字段的字符类型要一致。当类型不匹配时，MySQL会使用隐式转换,此时不会走索引. 2.5 OR改写为IN同一字段将OR改为IN. OR的效率为O(N),IN的效率为O(LOG N).N越大差距越大，当N很大时，OR会慢很多. 另外在使用IN的时候注意控制IN中的N个数. 2.6 合理的排序随机排序不要使用ORDER BY RAND()，使用其他方法替换. SELECT * FROM test1 ORDER BY RAND(LIMIT 1)该语句EXPLAIN type为ALL EXTRA为 Using File Sort.可以改为: SELECT id FROM test1 ORDER BY RAND(LIMIT 1); SELECT * FROM test1 WHERE id=?;这2个语句都使用到了索引，性能比较好. 2.7 HAVING子句HAVING在检索出所有记录后才会对结果集进行过滤.如果能通过where子句限制记录数量，那就能减少开销. 比如将： select * from test1 group by id having id &gt;3;替换为 select * from test1 where id &gt;3 group by id;2.8 使用合理的SQL语句减少与数据库的交互次数.减少与数据库的交互次数的SQL： `INSERT IGNORE` `INSERT INTO values()`改为 `INSERT … ON DUPLICATE KEY UPDATE`ON DUPLICATE KEY UPDATE 是一种高效的唯一键或者主键冲突判断. 冲突则执行UPDATE，不冲突则执行INSERT语句. 2.9 COUNT(*)在不加WHRER条件下count(col)跟count(*)差不多，但是在加入了WHERE条件后count(*)的性能比count(col)和count(1)好. MySQLcount(*) 对作了特殊处理. 2.10 or和union在MySQL5.6中优化了合并索引.一条SQL可以使用2个索引(INDEX_MERGE).但是如果三个字段的索引则使用不上索引合并.3个字段条件查找时候用UNION替代OR，如果不需要去重则用UNION ALL代替OR.(被查找的字段上都有相应的索引) 例如,下面的例子在数据均匀分布的情况下： `SELECT * FROM test1 WHERE id =&apos;3&apos; OR address =&apos;5&apos; or age =10`改为 SELECT * FROM test1 WHERE id =&apos;1&apos; UNION SELECT * FROM test1 WHERE address =&apos;5&apos; UNION SELETE * FROM test1 WHERE age =&apos;10&apos;`第一种只执行一步但是无法使用索引会全表扫描.第二种会执行4步，分别查询值然后再union result.虽然步骤多但是查询走索引，union result只是从union临时表获取结果集合. 性能比第一种好一些. 2.11 触发器，存储过程尽量减少触发器，存储过程的使用和MySQL函数对结果集的处理. 2.12 事务事务的原则是即开即用，用完即停.与事务无关的操作放到事务外面，减少锁资源的占用. 六. 数据库基本优化策略参考 面向程序员的数据库访问性能优化法则 数据库优化策略有以下几种方式： 减少数据访问（减少磁盘访问） 返回更少数据（减少网络传输或磁盘访问） 减少交互次数（减少网络传输） 减少服务器CPU开销（减少CPU及内存开销） 利用更多资源（增加资源） 这几种方法的收益如下图： 下面列出每种优化方式的一些具体方法。 1 减少数据访问1.1 创建并使用正确的索引通过合理的创建和使用索引来减少数据访问。 1.2 尽量通过索引访问数据合理利用覆盖索引. 1.3 优化SQL执行计划SQL执行计划是关系型数据库最核心的技术之一，它表示SQL执行时的数据访问算法。通过执行计划可以判断SQL是否合理。 2 返回更少数据2.1 数据分页处理通过分页的处理，减少数据的返回量。还有通过分表控制表的大小，增加查询的效率。 2.2 只返回需要的字段通过去除不必要的返回字段可以提高性能。 3 减少交互次数3.1 批量提交通过批量提交的方式来减少交互次数，如当你要往一个表中插入1000万条数据时，如果采用普通的executeUpdate处理，那么和服务器交互次数为1000万次，按每秒钟可以向数据库服务器提交10000次估算，要完成所有工作需要1000秒。如果采用批量提交模式，1000条提交一次，那么和服务器交互次数为1万次，交互次数大大减少。 3.2 合并查询语句for :var in ids[] do begin select * from mytable where id=:var; end;我们也可以做一个小的优化， 如下所示，用ID INLIST的这种方式写SQL： select * from mytable where id in(:id1,id2,...,idn);3.3 设置Fetch Size当我们采用select从数据库查询数据时，数据默认并不是一条一条返回给客户端的，也不是一次全部返回客户端的，而是根据客户端fetch_size参数处理，每次只返回fetch_size条记录，当客户端游标遍历到尾部时再从服务端取数据，直到最后全部传送完成。所以如果我们要从服务端一次取大量数据时，可以加大fetch_size，这样可以减少结果数据传输的交互次数及服务器数据准备时间，提高性能。 4 减少CPU开销4.1 使用绑定变量绑定变量是指SQL中对变化的值采用变量参数的形式提交，而不是在SQL中直接拼写对应的值。这样可以防止SQL注入并且提高SQL解析性能(硬解析变为软解析). 4.2 大量复杂运算在客户端处理一些复杂的运算，不要用数据库来处理.如含小数的对数及指数运算和加密处理等. 4.3 减少特殊比较操作和合理使用排序我们SQL的业务逻辑经常会包含一些比较操作，如a=b，a&lt;b之类的操作，对于这些比较操作数据库都体现得很好，但是对一些特殊的比较操作，我们需要保持警惕. （如：like和IN（1,2,….n）n值过多），另外在使用SQL的确定是否需要排序，大量数据排序会增加CPU的开销。详细例子在后面章节列出。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://btbib.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://btbib.com/tags/MySQL/"}]},{"title":"start.aliyun.com 正式上线！极速构建 Spring Cloud 应用","slug":"start-aliyun-com-正式上线！极速构建-Spring-Cloud-应用","date":"2020-03-25T01:33:38.000Z","updated":"2020-03-28T07:55:02.000Z","comments":true,"path":"2020-03-25-2.html","link":"","permalink":"http://btbib.com/2020-03-25-2.html","excerpt":"","text":"Photo @ Alibaba Initializr 官网 浏览器访问 ： https://start.aliyun.com","categories":[{"name":"阿里巴巴中间件","slug":"阿里巴巴中间件","permalink":"http://btbib.com/categories/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"Java后端","slug":"Java后端","permalink":"http://btbib.com/tags/Java%E5%90%8E%E7%AB%AF/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://btbib.com/tags/Spring-Cloud/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-15T08:22:20.000Z","updated":"2020-03-28T07:54:48.000Z","comments":true,"path":"2020-03-15-1.html","link":"","permalink":"http://btbib.com/2020-03-15-1.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://btbib.com/categories/hexo/"}],"tags":[]}]}